# SonarQube Properties Skill

## Purpose
Generate SonarQube project configuration file for code quality analysis, security scanning, and test coverage reporting in a Vue 3 TypeScript application.

## Output
Create the file: `sonar-project.properties`

## Configuration Requirements

### Project Identification

#### Project Key
- **Format**: Use your organization's naming convention (e.g., `adusa-digital-fulfillment_ex-facilitator_sup-{application-name}`)
- **Purpose**: Unique identifier for the project in SonarQube
- **Requirements**: Must be unique across your SonarQube instance
- **Characters**: Use alphanumeric, hyphens, underscores, and dots only

#### Project Name
- **Format**: Typically matches the project key or uses a human-readable variant
- **Purpose**: Display name in SonarQube dashboard
- **Best Practice**: Use the same value as project key for consistency

#### Project Description
- **Content**: Brief description of the application's purpose
- **Example**: "A Vue.js Micro Frontend Application for {Feature Name}"
- **Purpose**: Helps teams identify the project in multi-project environments

### Source Configuration

#### Source Directory
- **Path**: Set to your main source directory (typically `src`)
- **Purpose**: Tells SonarQube where to find code to analyze
- **Note**: Relative to the project root

#### Language
- **Value**: Specify primary language (use `ts` for TypeScript projects)
- **Purpose**: Enables language-specific analyzers and rules
- **Multi-language**: Can specify multiple languages if needed

#### Source Encoding
- **Value**: Use `UTF-8` for consistent character encoding
- **Purpose**: Ensures proper analysis of source files with special characters
- **Standard**: UTF-8 is the modern standard for most projects

### Version Control

#### SCM Provider
- **Value**: Specify version control system (typically `git`)
- **Purpose**: Enables SCM integration features like blame information
- **Options**: git, svn, mercurial, etc.

### Quality Gate

#### Wait for Quality Gate
- **Value**: Enable (typically `true`) to wait for analysis results
- **Purpose**: Allows CI/CD pipelines to fail if quality gate conditions aren't met
- **Use Case**: Enforce quality standards before deployment

### Test Coverage

#### Coverage Report Paths
Configure paths to coverage reports generated by your test framework:

**LCOV Format**
- **Property**: Coverage report in LCOV format
- **Path**: Location of lcov.info file (typically `./coverage/lcov.info`)
- **Purpose**: Primary coverage format for JavaScript/TypeScript projects

**Clover Format** (Optional)
- **Property**: Coverage report in Clover XML format
- **Path**: Location of clover.xml file (typically `./coverage/clover.xml`)
- **Purpose**: Alternative/supplementary coverage format

**Key Concepts**
- Paths are relative to project root
- Reports must be generated before SonarQube analysis
- Your test framework must be configured to output these formats

### Test Configuration

#### Test Directory
- **Path**: Directory containing test files (typically `src` for co-located tests)
- **Purpose**: Separates test code from production code analysis
- **Note**: May differ if tests are in a separate `tests/` or `__tests__/` directory

#### Test Inclusions
- **Pattern**: Glob pattern matching test files (e.g., `src/**/*.spec.ts`)
- **Purpose**: Explicitly identifies which files are tests
- **Common Patterns**:
  - `**/*.spec.ts` - Jest/Vitest spec files
  - `**/*.test.ts` - Alternative test file naming
  - `**/__tests__/**/*.ts` - Tests in __tests__ directories

### Exclusions

#### Analysis Exclusions
Exclude files from all analysis (duplications, complexity, issues):

**Common Exclusions**
- Test files (e.g., `src/**/*.spec.ts`)
- Configuration files
- Generated code
- Third-party code

#### Coverage Exclusions
Exclude specific files from coverage metrics (while still analyzing for other issues):

**Recommended Exclusions**
- **Entry Points**: Main application bootstrap file (e.g., `src/main.ts`)
  - *Reason*: Difficult to test in isolation, mostly boilerplate
  
- **Service Files**: API integration layers (e.g., `src/services/**/*.ts`)
  - *Reason*: Often thin wrappers around HTTP clients, tested via integration tests
  
- **Router Files**: Route configurations (e.g., `src/**/router/*.ts`, `src/router/**/*.ts`)
  - *Reason*: Declarative configuration, tested via E2E tests
  
- **Type Definitions**: Pure TypeScript type/interface files
  - *Reason*: No runtime code to test

- **Configuration Files**: App configuration (e.g., `src/config/**/*.ts`)
  - *Reason*: Simple data structures, minimal logic

**Important**: Use comma-separated list for multiple exclusions

## Best Practices

### Project Naming
- Use consistent naming conventions across all projects
- Include organizational hierarchy in project key
- Make names descriptive enough to identify the project at a glance

### Coverage Strategy
- Set realistic coverage targets based on code complexity
- Focus on business logic coverage rather than 100% coverage
- Exclude infrastructure code that's tested via integration/E2E tests

### Exclusion Philosophy
- Exclude from coverage only when:
  - Code is tested at a different level (E2E, integration)
  - Code is pure configuration with no logic
  - Testing would provide minimal value
- Document why files are excluded
- Review exclusions periodically as project evolves

### Multi-Module Projects
- Consider using module-level sonar properties for better organization
- Use consistent exclusion patterns across modules
- Coordinate quality gate settings with team standards

## Validation

After generating the configuration:
1. **Run Analysis**: Execute SonarQube scan locally or in CI
2. **Verify Coverage**: Check that coverage reports are imported correctly
3. **Review Exclusions**: Ensure excluded files don't appear in coverage metrics
4. **Quality Gate**: Confirm quality gate status reflects your standards
5. **Check Dashboard**: Review SonarQube dashboard for any configuration warnings

## Integration Notes

### Test Framework Configuration
Ensure your test framework generates the required coverage formats:

- **Jest**: Configure to output LCOV format
- **Vitest**: Configure coverage reporter to output LCOV format
- Both should generate reports in the `coverage/` directory

### CI/CD Integration
- Run tests and generate coverage before SonarQube analysis
- Use SonarQube scanner appropriate for your CI platform
- Pass authentication tokens securely via environment variables
- Consider using SonarQube's automatic branch detection

### Quality Gates
Define appropriate thresholds in SonarQube UI:
- Code coverage percentage
- New code coverage percentage
- Maintainability rating
- Reliability rating
- Security rating
- Code duplications

## Philosophy

This configuration aims to:
- **Enforce Quality Standards**: Catch issues before they reach production
- **Measure Coverage Meaningfully**: Focus metrics on testable business logic
- **Integrate with Workflow**: Work seamlessly with CI/CD pipelines
- **Provide Actionable Insights**: Help teams improve code quality over time
- **Balance Rigor and Practicality**: Set realistic goals that drive improvement

## Future Compatibility

When SonarQube evolves:
- Adopt new properties for enhanced analysis features
- Update language analyzers to leverage new capabilities
- Adjust exclusion patterns as project structure changes
- Refine coverage exclusions based on testing strategy evolution
- Replace deprecated properties with modern equivalents
- Maintain the core principles: meaningful metrics and actionable insights

## Common Adjustments

### Test File Location Variations
- If tests are in `tests/`: Update `sonar.tests` and inclusion patterns
- If using `__tests__/` folders: Adjust patterns accordingly
- Co-located tests (next to source): Keep `sonar.tests=src`

### Alternative Coverage Formats
- **Cobertura**: Use `sonar.coverage.cobertura.reportPaths`
- **JaCoCo**: Use `sonar.coverage.jacoco.xmlReportPaths`
- Choose format based on your test framework's output capabilities

### Monorepo Considerations
- May need multiple sonar-project.properties files
- Consider using sonar.modules property
- Coordinate shared configuration via sonar.properties