# App Starter Agent - Detailed Implementation Instructions

This file contains the **complete implementation specifications** for the `@app-starter` agent.

**Purpose**: This is the authoritative reference for agent execution, including question flows, configuration logic, skill orchestration, and validation procedures.

**For a high-level overview**, see [`../../app-starter.agent.md`](../../app-starter.agent.md)

## Question Flow Preference

**FIRST QUESTION - ALWAYS ASK THIS:**

**How would you like to provide the application configuration?**
- Options: `all-at-once` or `one-at-a-time`
- **`all-at-once`**: Display all questions together in a single list for the user to answer
- **`one-at-a-time`**: Interactive conversational flow where each question is asked individually after receiving the previous answer

Based on the user's choice:
- If **`all-at-once`**: Present questions 1-12 in a formatted list and wait for all answers
- If **`one-at-a-time`**: Ask questions 1-12 sequentially, waiting for each answer before proceeding

## Required User Input

Ask the user the following questions to gather the necessary parameters:

1. **What is the name of your application?** (in kebab-case, e.g., `omni-inventory-manager-web`)
   - This will be used as `application_name`
   - Used in: package.json name, vite.config.ts, README.md, index.html title

2. **What is your NPM scope/organization?** (e.g., `@pdl-fulfillment-omni`)
   - This will be used as `project_scope`
   - Used in: package.json name field
   - Format: `@{scope}/{application_name}`

3. **What base path should the router use?** (e.g., `/omni-inventory-manager`)
   - This will be used as `router_base_path`
   - Default format: `/` plus the application name without the `-web` suffix
   - Used in: Vue Router configuration

4. **What is the base API path for backend service proxying?** (e.g., `/omni-access-manager`, `/api`)
   - This will be used as `api_base_path`
   - Used in: Vite dev server proxy configuration, axios base URL

5. **What port should the development server use?** (e.g., `8089`)
   - This will be used as `default_port`
   - Used in: vite.config.ts server.port, README.md documentation, package.json scripts

6. **What type of application are you building?** 
   - Options: `micro-frontend` or `standalone`
   - **`micro-frontend`**: Your application will be part of a single-spa micro frontend architecture, where multiple applications can be composed together. This uses the SystemJS module format for dynamic loading and integration.
   - **`standalone`**: Your application will run independently as a traditional single-page application (SPA). This uses ES module format optimized for modern browsers.
   - This will be used as `application_type`
   - Internally maps to: `micro-frontend` → `vite_build_format: "system"`, `standalone` → `vite_build_format: "es"`
   - Used in: vite.config.ts build.lib.formats

### Optional Questions (Always Asked)

7. **Do you want to include a component library?** (default: no)
    - Options: `yes` or `no`
    - This will be used as `include_component_library`

8. **What Vue API pattern do you want to use?**
    - Options: `composition-api` or `options-api`
    - **`composition-api`**: Modern functional approach that organizes code by logical concerns using reactivity primitives like `ref()` and `reactive()`. Best for large applications requiring better code reusability and scalability through composables.
    - **`options-api`**: Traditional method that structures code into predefined options like `data`, `methods`, and `computed`. Familiar for developers coming from Vue 2.
    - This will be used as `vue_api_pattern`
    - Used in: Component template generation, view file structure
    - **Default recommendation**: `composition-api` for new Vue 3 projects

9. **What state management library do you want to use?**
    - Options: `pinia` or `vuex`
    - **`pinia`**: The recommended state management solution for Vue 3. Lightweight, intuitive API with built-in TypeScript support and great DevTools integration. Works seamlessly with Composition API.
    - **`vuex`**: The traditional Vue state management library. Still fully supported but considered legacy for new Vue 3 projects. Better suited for Options API or migrating from Vue 2.
    - This will be used as `state_management`
    - Used in: Store setup, store file generation, dependencies in package.json
    - **Default recommendation**: `pinia` for new Vue 3 projects

10. **What testing framework do you want to use?**
    - Options: `vitest` or `jest`
    - **`vitest`**: Modern testing framework built for Vite. Native ESM support, faster execution, better integration with Vite tooling, and includes UI mode for interactive testing.
    - **`jest`**: Mature and widely-used testing framework. Extensive ecosystem and documentation but requires additional configuration for ESM and Vite.
    - This will be used as `test_framework`
    - Used in: Test configuration files, test dependencies in package.json, test file templates
    - **Default recommendation**: `vitest` for new Vue 3 + Vite projects

11. **Do you want to use the latest package versions?**
    - Options: `yes` or `no`
    - **`yes`**: Automatically fetch and use the latest stable versions from npm registry for all packages (Vue, Vite, TypeScript, etc.)
    - **`no`**: Use pinned/tested versions specified in the template configuration
    - This will be used as `use_latest_versions`
    - Used in: package.json version resolution
    - **Default recommendation**: `yes` for new projects, `no` for production stability
    - **Note**: If `yes`, the generator will run `npm view <package> version` for each package and apply caret ranges

## Auto-Configured Parameters

The following are automatically set based on user selections:
- `vite_build_format`: Set based on `application_type` (`micro-frontend` → `"system"`, `standalone` → `"es"`)
- Package versions: Managed via `versions.json` or fetched from npm based on `use_latest_versions`

## Version Management

**IMPORTANT**: Package versions are managed centrally via `skills/package-json/versions.json`.

**How it works**:
- All package versions defined in `versions.json` (in package-json skill)
- Use `"latest"` to auto-fetch from npm registry at generation time
- Use specific versions (e.g., `"^6.3.5"`) to pin for stability
- The version-resolver skill resolves versions during generation

**When user requests "latest configuration"**:
1. Load `versions.json` from package-json skill
2. For packages marked as `"latest"`: Run `npm view <package> version`
3. Apply caret prefix: `3.5.13` → `^3.5.13`
4. Replace placeholders in templates: `{{vue_version}}` → `^3.5.13`

**Examples**:
```json
// All latest (development)
{
  "core": { "vue": "latest", "vite": "latest" }
}

// Pinned (production)
{
  "core": { "vue": "^3.5.13", "vite": "^6.3.5" }
}

// Mixed (hybrid)
{
  "core": { "vue": "latest", "typescript": "^5.7.3" }
}
```

**Key files**:
- `skills/package-json/SKILL.md` - Complete documentation with embedded version configuration
- `skills/package-json/reference/latest-versions.md` - Latest versions template

**DO NOT hardcode versions** in skills/examples. Use placeholders: `{{vue_version}}`, `{{vite_version}}`, etc.

## Static Parameters (Pre-configured)

The app will require latest Vue, TypeScript, and other libraries versions so verify whether the current node and npm versions are up to date before generating the project. If not, check whether the current node and npm versions are compatible with the latest stable versions of Vue, or inform the user to update their environment.

## Auto-Derived Parameters

The following parameters should be automatically derived from the user's inputs:

- `main_component_name`: Derived from `application_name` by removing dashes and using PascalCase (e.g., `omni-inventory-manager-web` → `OmniInventoryManagerWeb`)
  - Used in: Component names, class names

- `application_id`: Same as `application_name` in kebab-case, used for style tag IDs and CSS isolation
  - Used in: Style tag IDs in main.ts, CSS isolation, Datadog service name

- `service_name`: Same as `application_name` in kebab-case, used for service identification in monitoring
  - Used in: Datadog RUM configuration, logging

## Execution Order

The skills should be executed in the following order to ensure dependencies are properly handled:

### Phase 1: Configuration and Setup
1. **Configuration Skill** - Load and validate user configuration (interactive prompts or config.json)
2. **Conditional Generation Skill** - Determine which files to generate based on application type
3. Package JSON Skill
4. NPM RC Skill (if component library is included)
5. Git Ignore Skill
6. **Run `npm install`** to install dependencies
7. Component Library Skill (if include_component_library === true)

### Phase 2: Build Configuration
8. TypeScript Config Skill
9. Vite Config Skill
10. Environment Files Skill (env-local, env-standalone if micro-frontend)
11. Index HTML Skill
12. Public Folder Skill

### Phase 3: Code Quality
13. ESLint Config Skill
14. Browserlist Config Skill
15. Lint Staged Config Skill
16. Prettier Config Skill
17. Prettier Ignore Skill
18. Babel Config Skill (if using Jest)
19. Jest Config Skill (if test_framework === jest)
20. Vitest Config Skill (if test_framework === vitest)
21. Stylelint Config Skill
22. SonarQube Properties Skill
23. Husky Skill

### Phase 4: Application Structure
24. TypeScript Shims Skill
25. Global Constants Skill
26. Environment Constants Skill
27. Theme Skill
28. Router Skill
29. Store Skill (Vuex or Pinia based on configuration)
30. App Component Skill

### Phase 5: Views and Tests (CRITICAL - ALWAYS EXECUTE)
31. **View Components Skill** - Generate initial view components:
    - `src/views/Home/Home.vue`
    - `src/views/PageNotFoundView/PageNotFoundView.vue`
    - Templates based on `vue_api_pattern` (composition-api or options-api)
    
32. **Testing Skill** - Generate test files for all components and views:
    - `src/views/Home/Home.spec.ts`
    - `src/views/PageNotFoundView/PageNotFoundView.spec.ts`
    - `src/App.spec.ts`
    - Templates based on `test_framework`, `vue_api_pattern`, and `state_management`

33. Main Entry Skill (varies: single-spa lifecycle for micro-frontend, simple mount for standalone)

### Phase 6: Deployment
34. Docker Skill
35. Nginx Default Configuration Skill
36. Nginx Sites Available Skill
37. Entrypoint Skill

### Phase 7: Verification
- Verify directory structure exists:
  - `src/views/Home/Home.vue` ✓
  - `src/views/Home/Home.spec.ts` ✓
  - `src/views/PageNotFoundView/PageNotFoundView.vue` ✓
  - `src/views/PageNotFoundView/PageNotFoundView.spec.ts` ✓
  - `src/App.spec.ts` ✓
- Run `npm run lint` to verify linting setup
- Run `npx stylelint src/**/*.vue src/**/*.scss` to verify stylelint setup
- Run `npm run test` to verify test setup (tests MUST pass)
- Run `npm run build` to verify build configuration

## Pre-Execution Validations

Before beginning code generation, the agent MUST:

1. **Validate Environment**:
   - Check Node.js and npm versions are compatible with latest Vue 3 and Vite
   - If versions are outdated, inform user to update environment
   - Confirm that the target directory is empty or request permission to proceed

2. **Validate User Input**:
   - Ensure all required parameters (questions 1-11) are provided
   - Validate format of `application_name` (kebab-case)
   - Validate format of `project_scope` (starts with `@`)
   - Validate `router_base_path` and `api_base_path` formats
   - Validate `default_port` is a valid port number

3. **Verify Skill Availability**:
   - Confirm all required skill directories exist in `skills/`
   - Review skill templates and examples to understand implementation patterns
   - If component library is requested, verify component library skill is available

4. **Clarify Ambiguities**:
   - If user request is unclear, ask for clarification before proceeding
   - If templates contain unclear placeholders, ask for additional context
   - Never assume or guess critical configuration values

## Template Selection Logic

Based on user configuration, select appropriate templates:

**View Templates**:
- `composition-api` → Use `<script setup lang="ts">` pattern
- `options-api` → Use `export default defineComponent()` pattern

**Test Templates**:
- Combination of: `{test_framework}-{vue_api_pattern}-{state_management}`
- Examples:
  - `vitest-composition-pinia` → Vitest + Composition API + Pinia
  - `jest-options-vuex` → Jest + Options API + Vuex

**main.ts Templates**:
- `micro-frontend` → Single-spa lifecycle exports
- `standalone` → Simple createApp and mount

## Conditional File Generation

Based on `application_type`:

**Micro-Frontend**:
- Generate `.env.standalone` ✅
- Include `single-spa-vue` dependency ✅
- Use SystemJS build format (`system`) ✅
- Include `VITE_LAUNCHER_APP_URL` env var ✅

**Standalone**:
- Skip `.env.standalone` ❌
- Skip `single-spa-vue` dependency ❌
- Use ES module format (`es`) ✅
- Skip `VITE_LAUNCHER_APP_URL` env var ❌

## Critical Rules

### MANDATORY: Views and Tests Generation

**RULE 1**: ALWAYS generate initial view components
- The `view-components` skill MUST be executed in Phase 5
- Generates: `src/views/Home/Home.vue` and `src/views/PageNotFoundView/PageNotFoundView.vue`

**RULE 2**: ALWAYS generate test files for views and components
- The `testing` skill MUST be executed immediately after `view-components` in Phase 5
- Generates test files co-located with source files (not in separate tests/ directory)
- Test file naming: `{ComponentName}.spec.ts`

**RULE 3**: Test files MUST match configuration
- Use correct testing framework (`jest` vs `vitest`)
- Use correct API pattern (`composition-api` vs `options-api`)
- Use correct state management mocking (`pinia` vs `vuex`)

**WHY**: The testing skill documentation explicitly states:
> "Test files MUST be generated alongside UI components, views, stores, directives, and utilities."

## Post-Generation Tasks

After all skills have been executed, the agent should:

1. Create a `.env.local` file with placeholder values for required environment variables
2. Verify that all generated files follow the naming conventions
3. **Verify that views and tests were generated**:
   - Check `src/views/Home/Home.vue` exists
   - Check `src/views/Home/Home.spec.ts` exists
   - Check `src/views/PageNotFoundView/PageNotFoundView.vue` exists
   - Check `src/views/PageNotFoundView/PageNotFoundView.spec.ts` exists
   - Check `src/App.spec.ts` exists
4. Ensure that the application can be started with `npm run serve`
5. Run `npm run test` to verify all tests pass
6. Provide a summary of the generated structure and next steps for the developer
